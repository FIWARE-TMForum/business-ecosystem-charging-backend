# -*- coding: utf-8 -*-

# Copyright (c) 2015 - 2016 CoNWeT Lab., Universidad Polit√©cnica de Madrid

# This file belongs to the business-charging-backend
# of the Business API Ecosystem.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from decimal import Decimal

from bson import ObjectId
from logging import getLogger
from threading import Thread

from django.core.exceptions import ValidationError
from wstore.ordering.models import Offering
from wstore.models import Organization
from wstore.models import Context
from wstore.rss.models import CDR
from wstore.store_commons.database import get_database_connection

logger = getLogger("wstore.default_logger")


class CDRManager:
    _order = None

    def __init__(self, order, contract):
        self._offering = Offering.objects.get(pk=ObjectId(contract.offering))
        self._init_cdr_info(order, contract)

    def _init_cdr_info(self, order, contract):
        self._cdr_info = {
            "providerId": self._offering.owner_organization.name,
            "application": f"{self._offering.off_id} {self._offering.name} {self._offering.version}",
            "customerId": order.owner_organization.name,
            "productClass": contract.revenue_class,
            "currency": contract.pricing_model["general_currency"],
            "referenceCode": f"{order.order_id} {contract.item_id}",
        }

    def _generate_cdr_part(self, part, event, description):
        # Create connection for raw database access
        db = get_database_connection()

        # Take and increment the correlation number using
        # the mongoDB atomic access in order to avoid race
        # problems
        corr_number = db.wstore_organization.find_and_modify(
            query={"_id": self._offering.owner_organization.pk},
            update={"$inc": {"correlation_number": 1}},
        )["correlation_number"]

        cdr_part = {
            "correlationNumber": str(corr_number),
            "chargedAmount": Decimal(part["value"]),
            "chargedTaxAmount": Decimal(part["value"]) - Decimal(part["duty_free"]),
            "event": event,
            "description": description,
        }

        cdr_part.update(self._cdr_info)
        return cdr_part

    def generate_cdr(self, applied_parts, time_stamp):
        cdrs = []

        self._cdr_info["timestamp"] = time_stamp
        self._cdr_info["transactionType"] = CDR.TransactionTypes.CHARGE

        # Check the type of the applied parts
        if "single_payment" in applied_parts:
            # A cdr is generated for every price part
            for part in applied_parts["single_payment"]:
                description = f"One time payment: {part['value']} {self._cdr_info['currency']}"
                cdrs.append(self._generate_cdr_part(part, "One time payment event", description))

        if "subscription" in applied_parts:
            # A cdr is generated by price part
            for part in applied_parts["subscription"]:
                description = f"Recurring payment: {part['value']} {self._cdr_info['currency']} {part['unit']}"
                cdrs.append(self._generate_cdr_part(part, "Recurring payment event", description))

        if "accounting" in applied_parts:
            # A cdr is generated by price part
            for part in applied_parts["accounting"]:
                use_part = {
                    "value": part["price"],
                    "duty_free": part["duty_free"],
                }

                # Calculate the total consumption
                use = 0
                for sdr in part["accounting"]:
                    use += int(sdr["value"])
                    description = f"Fee per {part['model']['unit']}, Consumption: {use}"
                cdrs.append(self._generate_cdr_part(use_part, "Pay per use event", description))

        # Send the created CDRs to the Revenue Sharing System
        r = CDRRegistrationThread(cdrs)
        r.start()

    def refund_cdrs(self, price, duty_free, time_stamp):
        self._cdr_info["timestamp"] = time_stamp
        self._cdr_info["transactionType"] = CDR.TransactionTypes.REFUND

        # Create a payment part representing the whole payment
        aggregated_part = {
            "value": price,
            "duty_free": duty_free,
        }

        description = f"Refund event: {price} {self._cdr_info['currency']}"
        cdrs = [self._generate_cdr_part(aggregated_part, "Refund event", description)]

        # Send the created CDRs to the Revenue Sharing System
        r = CDRRegistrationThread(cdrs)
        r.start()


class CDRRegistrationThread(Thread):
    def __init__(self, cdr_info):
        super().__init__()
        self.cdr_info = cdr_info

    def run(self):
        register_cdr(self.cdr_info)


def register_cdr(self, cdr_info):
    failed_cdrs = []
    for cdr_record in cdr_info:
        try:
            cdr = CDR(**cdr_record)
            cdr.full_clean()
            cdr.save()

        except ValidationError as e:
            logger.error(f"Couldnt register CDR. \n{e}")
            failed_cdrs.append(cdr_record)

    db = get_database_connection()
    # Restore correlation numbers
    for cdr in failed_cdrs:
        org = Organization.objects.get(name=cdr["provider"])
        db.wstore_organization.find_and_modify(query={"_id": org.pk}, update={"$inc": {"correlation_number": -1}})[
            "correlation_number"
        ]

    context = Context.objects.all()[0]
    context.failed_cdrs.extend(failed_cdrs)
    context.save()
